---
title: "vimes: an illustration on a simulated dog rabies dataset"
author: "Anne Cori & Thibaut Jombart"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{demonsration}
  \usepackage[utf8]{inputenc}
---



```{r, echo = FALSE}

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  fig.width = 6, 
  fig.height = 6, 
  fig.path = "figs-demo/"
)

```

This vignette provides a demonstration of the vimes package and more specifically how it can be used to perform analyses such as those presented in XXXXXXXX [CITE THE PAPER]. Here we use a simulated dataset of rabies transmitted among dogs, chosen among all the baseline simulations described in XXXXXXXX [CITE THE PAPER] as the only simulated dataset with 151 observed dogs infected with rabies, i.e. exactly the same number as in the real dataset analysed in this paper. 

## Loading and examining the data

The simulated dataset is available as  `sim_rabies` in the vimes package:

```{r}
library(vimes)
data(sim_rabies)
sim_rabies$n

```

We can plot the epidemic curve using the `incidence` package:
```{r}
### if incidence is not already installed, run these few lines:
# install.packages("devtools")
# library(devtools)
# install_github("reconhub/incidence")

### load incidence package and use it to plot epidemic curve over different time scales:
library(incidence) 
# weekly
plot(incidence(sim_rabies$onset,7))
# monthly
plot(incidence(sim_rabies$onset,365/12))
# bimonthly
plot(incidence(sim_rabies$onset,365/6))
```

And we can plot the locations of the cases:
```{r}
locations <- t(sapply(1:sim_rabies$n, function(i) sim_rabies$cases[[i]]$location))
plot(locations, xlab = "", ylab="")
```

XXXXXXXXX THIBAUT CAN WE PLEASE ADD A PHYLOGENETIC TREE FOR THIS?


## Computing pairwise distances between cases in time, space, and genetics 


Distances between dates are computed as numbers of days:
```{r}
head(sim_rabies$onset, 5)
D_dates <- dist(sim_rabies$onset)
```

Distances between locations are computed using the great circle distance:
```{r}
library(fields)
head(locations)
D_geo <- rdist(locations)
```

Distances between sequences are computed as simple Hamming distances using function `dist_dna` in the `quicksim` package:
```{r}
#install_github("thibautjombart/quicksim")
library(quicksim)
dna <- lapply(1:sim_rabies$n, function(i) sim_rabies$cases[[i]]$dna)
# dna lists the mutation points compared to a reference genome for the pathogen sequence in each case
head(dna)
D_dna <- dist_dna(dna)
``` 

We format, match and plot the distance data using \emph{vimes}: XXX WHAT IS THE MATCHING USING HERE AS NOT USING IDs I THINK ?!
```{r} 
D_all <- vimes_data(dates = D_dates, geo = D_geo, dna = D_dna)
plot(D_all, nclass = 60)
``` 


## Defining cutoff distances above which cases are considered not linked by transmission 

### Distributions of expected distances between cases for rabies

We retrieved preexisting information about the serial interval, spatial kernel, and mutation rate for rabies, 
and used this information to define the distribution of expected distances between cases in the temporal, spatial, and genetic spaces. 

The serial interval and spatial kernel distributions are taken from Hampson et al. \url{http://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1000053}
```{r} 
# serial interval distribution parameters
gamma_mean <- 23.55
gamma_std <- 20.85
# convert into shape and scale 
gamma_shape <- gamma_mean^2 / (gamma_std^2)
gamma_scale <- gamma_std^2 / gamma_mean
```

XXXXXXXX NEED TO EXPLAIN MORE WHAT WE DO JUST BELOW AND MAYBE REMOVE RAYLEIGH_SD AS NOT USED?
```{r} 
# spatial kernel parameters
rayleigh_mean <- 0.88
# find Rayleigh parameters to match this mean
rayleigh_scale <- rayleigh_mean / sqrt(acos(-1)/2)  # using acos(-1) instead of pi as we later use pi for reporting rate
rayleigh_sd <- sqrt( rayleigh_scale^2*(4-acos(-1))/2 )  # using acos(-1) instead of pi as we later use pi for reporting rate
```

The mutation rate is derived from Bourhy et al. \url{http://journals.plos.org/plospathogens/article?id=10.1371/journal.ppat.1005525}
```{r} 
# mutation rate
mu_year_per_site <- 5.9e-4
n_sites <- 5061
# mutation rate per day and sequence
mu_day_whole <- (mu_year_per_site * n_sites / 365) 
```

We use the `fpaircase` function to compute the distributions of expected distances (temporal, spatial and genetic respectively) between a case and their infector based on the above parameters. 
```{r} 
## distance functions for each of the 3 types
f_temporal <- fpaircase(type = "temporal", gamma_shape = gamma_shape,
                        gamma_scale = gamma_scale)

f_spatial <- fpaircase(type = "spatial", sd_spatial = rayleigh_scale)

f_genetic <- fpaircase(type = "genetic", poisson_rate = mu_day_whole,
                       gamma_shape = gamma_shape, 
                       gamma_scale = gamma_scale)

# Plotting these
par(mfrow=c(3,1))
plot(f_temporal, xlim = c(0,365))
plot(f_spatial, xlim = c(0,5))
plot(f_genetic, xlim = c(0,5))
```

### Cutoff distances defined as the quantiles of the distributions of expected pairwise distances

We will be using the above distributions of expected distances between a case and their infector to define cutoff distances above which pairs of cases are considered not linked by transmission. 

First, we assume a certain level of reporting. Here we assume only $20\%$ of cases are observed. 
```{r} 
# reporting rate
pi <- 0.2
```

Then, we define the quantile we want to use to define the cutoff distances. Here, we consider three different quantiles to assess sensitivity of our results to this choice. 
```{r} 
# quantiles
q <- c(.90, .95, .95^(1/3))
# colours used to plot these
cols <- c("orange", "orangered", "darkred")
cutoff_choice <- q[2] # our main results are with the cutoff corresponding to the 95% quantile
```

We now plot the distributions of expected distances (temporal, spatial and genetic respectively) between a case and their closest observed ancestor, assuming that only $20\%$ of cases are reported. We also show the cutoffs corresponding to the quantiles defined above. 
```{r} 
## distance functions for each of the 3 types, accounting for reporting probability pi
## with quantiles q overlayed on the graphs
par(mfrow=c(3,1))
plot(f_temporal, q, xlim = c(0,365*2), pi = pi,
     lines_arg = list(col=cols, lwd=2))
plot(f_spatial, q, xlim = c(0,10), pi = pi,
     lines_arg = list(col=cols, lwd=2))
plot(f_genetic, q, xlim = c(0,10), pi = pi,
     lines_arg = list(col=cols, lwd=2))
```

We can overlay the graph above on top of the histogram of observed distances to see where these cutoffs fall with respect to our observations. 
```{r} 

### function used to generate a plot with distribution of observed and expected distances
plot_overlay <- function(dist, f, q, pi, xlab, breaks, resol = 1,
                         q_color = cols, hist_bordercolor = "grey", hist_color = "lightgrey")
{ # dist contains the observed distances
  # f is the distribution of expected distances between a case and their infector
  # q is the quantile or vector of quantiles of interest
  # pi is the reporting rate
  # xlab is the x axis label
  # breaks is the breaks used for plotting the histogram of dist
  # resol is the resolution used for plotting f
  # q_color is the colour or vector of colours used to show the cutofs associated with the quantile(s) q
  # hist_bordercolor is the colour used for the border of the histogram of dist
  # hist_color is the colour used for the filling of the histogram of dist
  qtl <- get_quantiles(f, q, pi = pi)
  hist(dist, col = hist_color, border = hist_bordercolor, 
       main="", xlab=xlab, 
       breaks=breaks)
  par(new = T)
  x <- seq(min(breaks), max(breaks), resol)
  y <- f(x, pi = pi)
  plot(x, y, type="l", axes=FALSE, main = "", xlab="", ylab="")
  # add vertical lines corresponding to quantiles
  abline(v = qtl, col = q_color, lwd = 2)
}

### use the function above to create our plot: 
par(mfrow=c(3, 1), mar=c(5, 5, 0.5, 5))

# temporal
plot_overlay(dist = as.vector(D_all$dates), 
             f = f_temporal, 
             q = q, 
             pi = pi, 
             xlab = "Pairwise distance in time (days)", 
             breaks = seq(0,2500, 50),
             resol = 1)

# spatial
plot_overlay(dist = as.vector(D_all$geo), 
             f = f_spatial, 
             q = q, 
             pi = pi, 
             xlab = "Pairwise distance in space (km)", 
             breaks = seq(0,20,0.2),
             resol = 0.1)

# genetic
plot_overlay(dist = as.vector(D_all$dna), 
             f = f_genetic, 
             q = q, 
             pi = pi, 
             xlab = "Pairwise distance in space (km)", 
             breaks = seq(0,55,1),
             resol = 1)
```

## Running vimes to identify clusters of cases linked by transmission

We run vimes to identify clusters of cases linked by transmission, for various cutoff choices, and various reporting rates. 
```{r} 
### function used to get results for a certain cutoff and reporting rate
get_res <- function(D_all, q, pi, f_temporal, f_spatial, f_genetic, type=c("all", "temporal","spatial", "genetic")) {
  
  type <- match.arg(type)
  
  ## get the cutoffs
  cuts <- c(temporal = get_quantiles(f_temporal, q, pi = pi), 
            spatial = get_quantiles(f_spatial, q, pi = pi),
            genetic = get_quantiles(f_genetic, q, pi = pi))
  
  if(type == "all")
  {
    ## use vimes
    out <- vimes(D_all, cutoff = cuts,
          graph.opt = vimes.graph.opt(col.pal=funky))
  }
  else if(type == "temporal")
  {
    out <- vimes(vimes_data(dates = D_all$dates), cutoff = cuts$temporal,
                 graph.opt = vimes.graph.opt(col.pal=funky))
  }else if(type == "spatial")
  {
    out <- vimes(vimes_data(geo = D_all$geo), cutoff = cuts$spatial,
                 graph.opt = vimes.graph.opt(col.pal=funky))
  }else if(type == "genetic")
  {
    out <- vimes(vimes_data(dna = D_all$dna), cutoff = cuts$genetic,
                 graph.opt = vimes.graph.opt(col.pal=funky))
  }
    
  return(out)
  
}

### use the function above to generate results for several combinations of p and pi
### We assume, as in Bourhy et al., a reporting rate of 20% in our main analyses, and reporting rates of 10 and 50% respectively in two extreme scenarios considered in sensitivity analyses. 

combi <- expand.grid(p = q,
                     pi = c(0.5, 0.2, 0.1))
combi

res <- vector(9L, mode = "list")

for (i in 1:nrow(combi)) {
  res[[i]] <- get_res(D_all, combi[i, 1], combi[i, 2], f_temporal, f_spatial, f_genetic)
}

### visualise the output
par(mfrow = c(3, 3), mar=c(1,1,3,1))

for(i in 1:length(res)) {
  plot(res[[i]]$graph, vertex.label="",
       main = paste(
         "cutoff:", round(100 * combi[i, 1]), "%",
         "reporting:", 100 * combi[i, 2],"%"))
}

```

